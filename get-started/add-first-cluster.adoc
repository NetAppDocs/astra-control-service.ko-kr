---
sidebar: sidebar 
permalink: get-started/add-first-cluster.html 
keywords: discover cluster, add cluster, add kubernetes cluster, discover kubernetes cluster, add cluster 
summary: 환경을 설정한 후에는 Kubernetes 클러스터를 생성하고 Astra Control Service에 추가할 준비가 된 것입니다. 
---
= Astra Control Service에서 Kubernetes 클러스터 관리를 시작합니다
:hardbreaks:
:allow-uri-read: 
:icons: font
:imagesdir: ../media/get-started/


[role="lead"]
환경을 설정한 후에는 Kubernetes 클러스터를 생성하고 Astra Control Service에 추가할 준비가 된 것입니다.

* <<Kubernetes 클러스터를 생성합니다>>
* <<Kubernetes 클러스터 관리를 시작합니다>>
* <<기본 스토리지 클래스를 변경합니다>>




== Kubernetes 클러스터를 생성합니다

클러스터가 아직 없는 경우 요건에 맞는 클러스터를 생성할 수 있습니다 link:set-up-amazon-web-services.html#eks-cluster-requirements["Amazon Elastic Kubernetes Service(EKS)에 대한 Astra Control 서비스 요구사항"]. 클러스터가 아직 없는 경우 요건에 맞는 클러스터를 생성할 수 있습니다 link:set-up-google-cloud.html#gke-cluster-requirements["Google Kubernetes Engine(GKE)에 대한 Astra Control Service 요구 사항"]. 클러스터가 아직 없는 경우 요건에 맞는 클러스터를 생성할 수 있습니다 link:set-up-microsoft-azure-with-anf.html#azure-kubernetes-service-cluster-requirements["Azure NetApp Files를 사용하는 Azure Kubernetes Service(AKS)에 대한 Astra Control 서비스 요구사항"] 또는 link:set-up-microsoft-azure-with-amd.html#azure-kubernetes-service-cluster-requirements["Azure 관리 디스크를 사용하는 Azure Kubernetes Service(AKS)에 대한 Astra Control Service 요구 사항"].


NOTE: Astra Control Service는 인증 및 ID 관리를 위해 Azure Active Directory(Azure AD)를 사용하는 AKS 클러스터를 지원합니다. 클러스터를 생성할 때 의 지침을 따릅니다 https://docs.microsoft.com/en-us/azure/aks/managed-aad["공식 문서"^] Azure AD를 사용하도록 클러스터를 구성합니다. 클러스터가 AKS로 관리되는 Azure AD 통합에 대한 요구 사항을 충족하는지 확인해야 합니다.



=== 자가 관리 클러스터

자가 관리형 클러스터는 직접 프로비저닝하고 관리하는 클러스터입니다. Astra Control Service는 퍼블릭 클라우드 환경에서 실행되는 자체 관리형 클러스터를 지원합니다. A를 업로드하여 자가 관리 클러스터를 Astra Control Service에 추가할 수 있습니다 `kubeconfig.yaml` 파일. 클러스터가 에 나와 있는 요구 사항을 충족하는지 확인해야 합니다 <<Kubernetes 클러스터 관리를 시작합니다>>.



== Kubernetes 클러스터 관리를 시작합니다

Astra Control Service에 로그인한 후 첫 번째 단계는 클러스터 관리를 시작하는 것입니다. 클라우드 공급자가 관리하는 클러스터 또는 자가 관리 클러스터를 추가할 수 있습니다. Astra Control Service에 클러스터를 추가하려면 먼저 특정 작업을 수행하고 클러스터가 특정 요구 사항을 충족하는지 확인해야 합니다.

.무엇을 &#8217;클라우드 제공업체가 관리하는 클러스터에 필요합니다
[%collapsible]
====
ifdef::aws[]

.Amazon Web Services에서 직접 지원합니다
* 클러스터를 생성한 IAM 사용자의 자격 증명이 포함된 JSON 파일이 있어야 합니다. link:../get-started/set-up-amazon-web-services.html#create-an-iam-user["IAM 사용자를 생성하는 방법을 알아봅니다"].
* NetApp ONTAP용 Amazon FSx에는 Astra Trident가 필요합니다. NetApp ONTAP용 Amazon FSx를 EKS 클러스터의 스토리지 백엔드로 사용하려는 경우 의 Astra Trident 정보를 참조하십시오 link:set-up-amazon-web-services.html#eks-cluster-requirements["EKS 클러스터 요구 사항"].
* (선택 사항) 제공해야 하는 경우 `kubectl` 클러스터 생성자가 아닌 다른 IAM 사용자에 대한 클러스터에 대한 명령 액세스는 의 지침을 참조하십시오 https://aws.amazon.com/premiumsupport/knowledge-center/amazon-eks-cluster-access/["Amazon EKS에서 클러스터를 생성한 후 다른 IAM 사용자 및 역할에 대한 액세스를 제공하려면 어떻게 해야 합니까?"^].
* NetApp Cloud Volumes ONTAP를 스토리지 백엔드로 사용하려는 경우 Amazon Web Services와 연동되도록 Cloud Volumes ONTAP를 구성해야 합니다. Cloud Volumes ONTAP를 참조하십시오 https://docs.netapp.com/us-en/cloud-manager-cloud-volumes-ontap/task-getting-started-aws.html["설치 설명서"^].


endif::aws[]

ifdef::azure[]

.Microsoft Azure를 참조하십시오
* 서비스 보안 주체를 생성할 때 Azure CLI의 출력이 포함된 JSON 파일이 있어야 합니다. link:../get-started/set-up-microsoft-azure-with-anf.html#create-an-azure-service-principal-2["서비스 보안 주체를 설정하는 방법에 대해 알아봅니다"].
+
JSON 파일에 추가하지 않은 경우 Azure 구독 ID도 필요합니다.

* 전용 AKS 클러스터의 경우 를 참조하십시오 link:manage-private-cluster.html["Astra Control Service에서 프라이빗 클러스터를 관리합니다"^].
* NetApp Cloud Volumes ONTAP를 스토리지 백엔드로 사용하려는 경우 Microsoft Azure와 연동하도록 Cloud Volumes ONTAP를 구성해야 합니다. Cloud Volumes ONTAP를 참조하십시오 https://docs.netapp.com/us-en/cloud-manager-cloud-volumes-ontap/task-getting-started-azure.html["설치 설명서"^].


endif::azure[]

ifdef::gcp[]

.Google 클라우드
* 필요한 권한이 있는 서비스 계정에 대한 서비스 계정 키 파일이 있어야 합니다. link:../get-started/set-up-google-cloud.html#create-a-service-account["서비스 계정 설정 방법에 대해 알아보십시오"].
* NetApp Cloud Volumes ONTAP를 스토리지 백엔드로 사용하려는 경우 Cloud Volumes ONTAP이 Google Cloud와 연동되도록 구성해야 합니다. Cloud Volumes ONTAP를 참조하십시오 https://docs.netapp.com/us-en/cloud-manager-cloud-volumes-ontap/task-getting-started-gcp.html["설치 설명서"^].


endif::gcp[]

====
.무엇을 &#8217;자체 관리 클러스터에 필요합니다
[%collapsible]
====
자가 관리형 클러스터는 직접 프로비저닝하고 관리하는 클러스터입니다. Astra Control Service는 퍼블릭 클라우드 환경에서 실행되는 자체 관리형 클러스터를 지원합니다. 자체 관리 클러스터는 Astra Trident를 사용하여 NetApp 스토리지 서비스와 인터페이스하거나 CSI(컨테이너 스토리지 인터페이스) 드라이버를 사용하여 Amazon EBS(Elastic Block Store), Azure Managed Disks 및 Google Persistent Disk와 인터페이스할 수 있습니다.

Astra Control Service는 다음과 같은 Kubernetes 배포를 사용하는 자체 관리 클러스터를 지원합니다.

* Red Hat OpenShift Container Platform
* Rancher Kubernetes 엔진
* 업스트림 Kubernetes


자가 관리형 클러스터는 다음 요구사항을 충족해야 합니다.

* 클러스터를 인터넷을 통해 액세스할 수 있어야 합니다.
* 클러스터는 사내 네트워크 내에서 호스팅할 수 없으며 퍼블릭 클라우드 환경에서 호스팅되어야 합니다.
* CSI 드라이버로 활성화된 스토리지를 사용 중이거나 사용할 계획이면 해당 CSI 드라이버가 클러스터에 설치되어 있어야 합니다. CSI 드라이버를 사용하여 스토리지를 통합하는 방법에 대한 자세한 내용은 스토리지 서비스 설명서를 참조하십시오.
* NetApp 스토리지를 사용 중이거나 사용할 계획인 경우, 최신 버전의 Astra Trident를 설치했는지 확인합니다.
+

NOTE: 가능합니다 https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy.html#choose-the-deployment-method["Astra Trident 구축"^] Trident 연산자(수동 또는 제어 차트 사용) 또는 를 사용합니다 `tridentctl`. Astra Trident를 설치 또는 업그레이드하기 전에 을 검토하십시오 https://docs.netapp.com/us-en/trident/trident-get-started/requirements.html["지원되는 프런트엔드, 백엔드 및 호스트 구성"^].

+
** * Trident 스토리지 백엔드가 구성됨 *: Astra Trident 스토리지 백엔드가 하나 이상 있어야 합니다 https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-postdeployment.html#step-1-create-a-backend["구성됨"^] 클러스터에서.
** * 구성된 Trident 스토리지 클래스 *: Astra Trident 스토리지 클래스가 하나 이상 있어야 합니다 https://docs.netapp.com/us-en/trident/trident-use/manage-stor-class.html["구성됨"^] 클러스터에서. 기본 스토리지 클래스가 구성된 경우 하나의 스토리지 클래스에만 해당 주석이 있어야 합니다.
** * Astra Trident 볼륨 스냅샷 컨트롤러 및 볼륨 스냅샷 클래스 설치 및 구성 *: 볼륨 스냅샷 컨트롤러가 되어야 합니다 https://docs.netapp.com/us-en/trident/trident-use/vol-snapshots.html#deploying-a-volume-snapshot-controller["설치되어 있습니다"^] 따라서 Astra Control에서 스냅샷을 생성할 수 있습니다. Astra Trident가 하나 이상 있어야 합니다 `VolumeSnapshotClass` 있습니다 https://docs.netapp.com/us-en/trident/trident-use/vol-snapshots.html#step-1-set-up-a-volumesnapshotclass["설정"^] 관리자의 경우.


* * Kubecon무화과 액세스 가능 *: 에 액세스할 수 있습니다 <<kubeconfig,클러스터 쿠베토무화과>> 여기에는 하나의 컨텍스트 요소만 포함됩니다.
* * Rancher 전용 *: Rancher 환경에서 애플리케이션 클러스터를 관리할 때 Rancher가 제공하는 kubecon무화과 파일에서 애플리케이션 클러스터의 기본 컨텍스트를 수정하여 Rancher API 서버 컨텍스트 대신 컨트롤 플레인 컨텍스트를 사용합니다. 따라서 Rancher API 서버의 부하가 줄어들고 성능이 향상됩니다.


.(선택 사항) Astra Trident 버전을 확인하십시오
클러스터에서 스토리지 서비스에 Astra Trident를 사용하는 경우 설치된 버전의 Astra Trident가 최신 버전인지 확인하십시오.

.단계
. Astra Trident 버전을 확인합니다.
+
[source, console]
----
kubectl get tridentversions -n trident
----
+
Astra Trident가 설치된 경우 다음과 유사한 출력이 표시됩니다.

+
[listing]
----
NAME      VERSION
trident   22.10.0
----
+
Astra Trident가 설치되지 않은 경우 다음과 유사한 출력이 표시됩니다.

+
[listing]
----
error: the server doesn't have a resource type "tridentversions"
----
+

NOTE: Astra Trident가 설치되지 않았거나 최신 버전이 아닌 경우, 클러스터에서 스토리지 서비스에 Astra Trident를 사용하려면 계속하기 전에 최신 버전의 Astra Trident를 설치해야 합니다. 을 참조하십시오 https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy.html["Astra Trident 문서"^] 를 참조하십시오.

. Pod가 실행 중인지 확인합니다.
+
[source, console]
----
kubectl get pods -n trident
----
. 스토리지 클래스가 지원되는 Astra Trident 드라이버를 사용하고 있는지 확인합니다. 공급자 이름은 이어야 합니다 `csi.trident.netapp.io`. 다음 예를 참조하십시오.
+
[source, console]
----
kubectl get sc
----
+
샘플 반응:

+
[listing]
----
NAME                   PROVISIONER                    RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
ontap-gold (default)   csi.trident.netapp.io          Delete          Immediate           true                   5d23h
----


.관리자 역할 kubecononfig 생성(Rancher, OpenShift 및 업스트림 Kubernetes를 실행하는 클러스터에 적용)
단계를 수행하기 전에 시스템에 다음 사항이 있는지 확인하십시오.

* KUBectl V1.19 이상이 설치되어 있습니다
* 활성 컨텍스트에 대한 클러스터 관리자 권한이 있는 활성 kubecononfig


.단계
. 다음과 같이 서비스 계정을 생성합니다.
+
.. 라는 서비스 계정 파일을 생성합니다 `astracontrol-service-account.yaml`.
+
필요에 따라 이름 및 네임스페이스를 조정합니다. 여기에서 변경한 경우 다음 단계에서 동일한 변경 사항을 적용해야 합니다.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-service-account.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: astracontrol-service-account
  namespace: default
----
.. 서비스 계정 적용:
+
[source, console]
----
kubectl apply -f astracontrol-service-account.yaml
----


. 다음과 같이 클러스터 관리자 권한을 부여합니다.
+
.. 을 생성합니다 `ClusterRoleBinding` 파일을 호출했습니다 `astracontrol-clusterrolebinding.yaml`.
+
필요에 따라 서비스 계정을 생성할 때 수정된 모든 이름과 네임스페이스를 조정합니다.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-clusterrolebinding.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: astracontrol-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: astracontrol-service-account
  namespace: default
----
.. 클러스터 역할 바인딩을 적용합니다.
+
[source, console]
----
kubectl apply -f astracontrol-clusterrolebinding.yaml
----


. 교체 서비스 계정 암호를 나열합니다 `<context>` 올바른 설치 상황:
+
[source, console]
----
kubectl get serviceaccount astracontrol-service-account --context <context> --namespace default -o json
----
+
출력의 끝은 다음과 유사합니다.

+
[listing]
----
"secrets": [
{ "name": "astracontrol-service-account-dockercfg-vhz87"},
{ "name": "astracontrol-service-account-token-r59kr"}
]
----
+
의 각 요소에 대한 인덱스입니다 `secrets` 어레이는 0으로 시작합니다. 위의 예에서 의 인덱스입니다 `astracontrol-service-account-dockercfg-vhz87` 는 0이고 의 인덱스입니다 `astracontrol-service-account-token-r59kr` 1입니다. 출력에서 "token"이라는 단어가 포함된 서비스 계정 이름의 인덱스를 기록해 둡니다.

. 다음과 같이 kubecononfig를 생성합니다.
+
.. 을 생성합니다 `create-kubeconfig.sh` 파일. 대치 `TOKEN_INDEX` 다음 스크립트의 시작 부분에 올바른 값이 있습니다.
+
[source, subs="specialcharacters,quotes"]
----
*create-kubeconfig.sh*
----
+
[source, console]
----
# Update these to match your environment.
# Replace TOKEN_INDEX with the correct value
# from the output in the previous step. If you
# didn't change anything else above, don't change
# anything else here.

SERVICE_ACCOUNT_NAME=astracontrol-service-account
NAMESPACE=default
NEW_CONTEXT=astracontrol
KUBECONFIG_FILE='kubeconfig-sa'

CONTEXT=$(kubectl config current-context)

SECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.secrets[TOKEN_INDEX].name}')
TOKEN_DATA=$(kubectl get secret ${SECRET_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.data.token}')

TOKEN=$(echo ${TOKEN_DATA} | base64 -d)

# Create dedicated kubeconfig
# Create a full copy
kubectl config view --raw > ${KUBECONFIG_FILE}.full.tmp

# Switch working context to correct context
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp config use-context ${CONTEXT}

# Minify
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp \
  config view --flatten --minify > ${KUBECONFIG_FILE}.tmp

# Rename context
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  rename-context ${CONTEXT} ${NEW_CONTEXT}

# Create token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-credentials ${CONTEXT}-${NAMESPACE}-token-user \
  --token ${TOKEN}

# Set context to use token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --user ${CONTEXT}-${NAMESPACE}-token-user

# Set context to correct namespace
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --namespace ${NAMESPACE}

# Flatten/minify kubeconfig
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  view --flatten --minify > ${KUBECONFIG_FILE}

# Remove tmp
rm ${KUBECONFIG_FILE}.full.tmp
rm ${KUBECONFIG_FILE}.tmp
----
.. Kubernetes 클러스터에 적용할 명령을 소스 하십시오.
+
[source, console]
----
source create-kubeconfig.sh
----


. (선택 사항) kubeconfig의 이름을 클러스터의 의미 있는 이름으로 바꿉니다. 클러스터 자격 증명을 보호합니다.
+
[listing]
----
chmod 700 create-kubeconfig.sh
mv kubeconfig-sa YOUR_CLUSTER_NAME_kubeconfig
----


====
.단계
. 대시보드에서 * Kubernetes 클러스터 관리 * 를 선택합니다.
+
표시되는 메시지에 따라 클러스터를 추가합니다.

. * 공급자 *: 클라우드 공급자를 선택한 다음 새 클라우드 인스턴스를 생성하는 데 필요한 자격 증명을 제공하거나 사용할 기존 클라우드 인스턴스를 선택하십시오.


ifdef::aws[]

. * Amazon Web Services *: JSON 파일을 업로드하거나 클립보드에서 해당 JSON 파일의 콘텐츠를 붙여넣어 Amazon Web Services IAM 사용자 계정에 대한 세부 정보를 제공합니다.
+
JSON 파일에는 클러스터를 생성한 IAM 사용자의 자격 증명이 포함되어야 합니다.



endif::aws[]

ifdef::azure[]

. * Microsoft Azure *: JSON 파일을 업로드하거나 클립보드에서 해당 JSON 파일의 내용을 붙여넣어 Azure 서비스 보안 주체에 대한 세부 정보를 제공합니다.
+
JSON 파일에는 서비스 보안 주체를 생성할 때 Azure CLI의 출력이 포함되어야 합니다. 또한 구독 ID를 포함할 수 있으므로 Astra에 자동으로 추가됩니다. 그렇지 않으면 JSON을 제공한 후 ID를 수동으로 입력해야 합니다.



endif::azure[]

ifdef::gcp[]

. * Google Cloud Platform *: 파일을 업로드하거나 클립보드의 콘텐츠를 붙여 넣어 서비스 계정 키 파일을 제공합니다.
+
Astra Control Service는 서비스 계정을 사용하여 Google Kubernetes Engine에서 실행 중인 클러스터를 검색합니다.



endif::gcp[]

. * 기타 *: 을 업로드하여 자체 관리되는 클러스터에 대한 세부 정보를 제공합니다 `kubeconfig.yaml` 파일을 클릭하거나 의 내용을 붙여 넣습니다 `kubeconfig.yaml` 파일을 클립보드에 저장합니다.
+

NOTE: 직접 만드는 경우 `kubeconfig` 파일에서 * 하나의 * 컨텍스트 요소만 정의해야 합니다. 을 참조하십시오 https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/["Kubernetes 문서"^] 을 참조하십시오 `kubeconfig` 파일.

+
.. * 클라우드 인스턴스 이름 * (공급자 관리 클러스터의 경우): 이 클러스터를 추가할 때 생성될 새 클라우드 인스턴스의 이름을 입력합니다. 에 대해 자세히 알아보십시오 link:../use/manage-cloud-instances.html["클라우드 인스턴스"].
+

NOTE: 클러스터 목록에서 선택할 때는 해당하는 탭에 세심한 주의를 기울이십시오. 경고가 나타나면 경고 위로 마우스를 이동하여 클러스터에 문제가 있는지 확인합니다. 예를 들어 클러스터에 작업자 노드가 없는 것을 식별할 수 있습니다.





ifdef::azure[]

를 누릅니다


NOTE: "Private" 아이콘이 표시된 클러스터를 선택하면 해당 클러스터는 전용 IP 주소를 사용하며 Astra Control이 클러스터를 관리하는 데 Astra Connector가 필요합니다. Astra Connector를 설치해야 한다는 메시지가 나타나면 link:manage-private-cluster.html["이 지침을 참조하십시오"] Astra Connector를 설치하고 클러스터 관리를 활성화합니다. Astra Connector를 설치한 후에는 클러스터를 사용할 수 있으며 클러스터를 계속 추가할 수 있습니다.

endif::azure[]

. * 자격 증명 이름 * (자체 관리 클러스터의 경우): Astra Control에 업로드하는 자체 관리 클러스터 자격 증명의 이름을 입력합니다. 기본적으로 자격 증명 이름은 클러스터 이름으로 자동 채워집니다.
. (선택 사항) * 스토리지 *: 기본적으로 이 클러스터에 Kubernetes 애플리케이션을 배포할 스토리지 클래스를 선택하십시오.
+
[NOTE]
====
각 클라우드 공급자의 스토리지 서비스에는 다음과 같은 가격, 성능 및 복원력 정보가 표시됩니다.

ifdef::gcp[]

** Google Cloud용 Cloud Volumes Service: 가격, 성능 및 복원력 정보
** Google 영구 디스크: 가격, 성능 또는 복원력 정보를 사용할 수 없습니다


endif::gcp[]

ifdef::azure[]

** Azure NetApp Files: 성능 및 복원력 정보
** Azure 관리 디스크: 사용 가능한 가격, 성능 또는 복원력 정보가 없습니다


endif::azure[]

ifdef::aws[]

** Amazon Elastic Block Store: 가격, 성능 또는 복원력 정보를 사용할 수 없습니다
** NetApp ONTAP용 Amazon FSx: 가격, 성능 또는 복원력 정보 없음


endif::aws[]

** NetApp Cloud Volumes ONTAP: 가격, 성능 또는 복원력 정보를 제공할 수 없습니다


====
+
각 스토리지 클래스는 다음 서비스 중 하나를 활용할 수 있습니다.



ifdef::gcp[]

* https://cloud.netapp.com/cloud-volumes-service-for-gcp["Google Cloud용 Cloud Volumes Service"^]
* https://cloud.google.com/persistent-disk/["Google 영구 디스크"^]


endif::gcp[]

ifdef::azure[]

* https://cloud.netapp.com/azure-netapp-files["Azure NetApp Files"^]
* https://docs.microsoft.com/en-us/azure/virtual-machines/managed-disks-overview["Azure로 관리되는 디스크"^]


endif::azure[]

ifdef::aws[]

* https://docs.aws.amazon.com/ebs/["Amazon Elastic Block Store를 클릭합니다"^]
* https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/what-is-fsx-ontap.html["NetApp ONTAP용 Amazon FSx"^]


endif::aws[]

* https://www.netapp.com/cloud-services/cloud-volumes-ontap/what-is-cloud-volumes/["NetApp Cloud Volumes ONTAP를 참조하십시오"^]
+
에 대해 자세히 알아보십시오 link:../learn/aws-storage.html["Amazon Web Services 클러스터용 스토리지 클래스입니다"]. 에 대해 자세히 알아보십시오 link:../learn/azure-storage.html["AKS 클러스터용 스토리지 클래스입니다"]. 에 대해 자세히 알아보십시오 link:../learn/choose-class-and-size.html["GKE 클러스터용 저장소 클래스"].

+
.. * 검토 및 승인 *: 구성 세부 정보를 검토하고 * 클러스터 추가 * 를 선택합니다.




.결과
* 공급자 관리 클러스터 *: 이 클라우드 공급자를 위해 추가한 첫 번째 클러스터인 경우 Astra Control Service는 해당 클러스터에서 실행되는 애플리케이션 백업을 위해 클라우드 공급자를 위한 오브젝트 저장소를 생성합니다. (이 클라우드 공급자에 후속 클러스터를 추가할 경우 더 이상 오브젝트 저장소가 생성되지 않습니다.) 기본 스토리지 클래스를 지정한 경우 Astra Control Service는 사용자가 지정한 기본 스토리지 클래스를 설정합니다. Amazon Web Services 또는 Google Cloud Platform에서 관리되는 클러스터의 경우 Astra Control Service는 클러스터에 관리자 계정도 생성합니다. 이 작업은 몇 분 정도 걸릴 수 있습니다.



== 기본 스토리지 클래스를 변경합니다

클러스터의 기본 스토리지 클래스를 변경할 수 있습니다.



=== Astra Control을 사용하여 기본 스토리지 클래스를 변경합니다

Astra Control 내에서 클러스터의 기본 스토리지 클래스를 변경할 수 있습니다. 클러스터에서 이전에 설치된 스토리지 백엔드 서비스를 사용하는 경우 이 방법을 사용하여 기본 스토리지 클래스를 변경하지 못할 수 있습니다(* 기본값으로 설정* 작업은 선택할 수 없음). 이 경우 를 사용할 수 있습니다 <<명령줄을 사용하여 기본 스토리지 클래스를 변경합니다>>.

.단계
. Astra Control Service UI에서 * Clusters * 를 선택합니다.
. 클러스터 * 페이지에서 변경할 클러스터를 선택합니다.
. Storage * 탭을 선택합니다.
. 스토리지 클래스 * 범주를 선택합니다.
. 기본값으로 설정할 스토리지 클래스에 대해 * Actions * 메뉴를 선택합니다.
. Set as default * 를 선택합니다.




=== 명령줄을 사용하여 기본 스토리지 클래스를 변경합니다

Kubernetes 명령을 사용하여 클러스터의 기본 스토리지 클래스를 변경할 수 있습니다. 이 방법은 클러스터의 구성에 관계없이 작동합니다.

.단계
. Kubernetes 클러스터에 로그인합니다.
. 클러스터의 스토리지 클래스를 나열합니다.
+
[source, console]
----
kubectl get storageclass
----
. 기본 스토리지 클래스에서 기본 지정을 제거합니다. <SC_NAME>를 스토리지 클래스 이름으로 바꿉니다.
+
[source, console]
----
kubectl patch storageclass <SC_NAME> -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}'
----
. 다른 스토리지 클래스를 기본값으로 표시합니다. <SC_NAME>를 스토리지 클래스 이름으로 바꿉니다.
+
[source, console]
----
kubectl patch storageclass <SC_NAME> -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'
----
. 새 기본 스토리지 클래스를 확인합니다.
+
[source, console]
----
kubectl get storageclass
----


ifdef::azure[]



== 를 참조하십시오

* link:manage-private-cluster.html["프라이빗 클러스터 관리"]


endif::azure[]
